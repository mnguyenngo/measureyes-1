"""
Adapted from AWS Rekognition demo (accessed Sept 2018): https://docs.aws.amazon.com/rekognition/latest/dg/video-analyzing-with-sqs.html
Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
PDX-License-Identifier: MIT-0 (For details, see https://github.com/awsdocs/amazon-rekognition-developer-guide/blob/master/LICENSE-SAMPLECODE.)

NOTE: This script deploys AWS Rekognition PersonTracking. Unique persons detected
within the targe video are indexed, but those indexed identities are not preserved
beyond the context of the response generated by analysis of the video.

"""

import boto3
import json
import sys


class VideoDetect(object):
    jobId = 'RekogPersonTrakcingTest01'
    rek = boto3.client('rekognition')
    queueUrl = ''
    roleArn = ''
    topicArn = ''
    bucket = ''
    video = ''

    def main(self):

        jobFound = False
        sqs = boto3.client('sqs')

        #=====================================
        response = self.rek.start_person_tracking(
            Video={'S3Object':{'Bucket':self.bucket,'Name':self.video}},
            NotificationChannel={'RoleArn':self.roleArn, 'SNSTopicArn':self.topicArn},
            JobTag=self.jobId
            )
        #=====================================
        print('Start Job Id: ' + response['JobId'])
        dotLine=0
        while jobFound == False:
            sqsResponse = sqs.receive_message(QueueUrl=self.queueUrl, MessageAttributeNames=['ALL'],
                                          MaxNumberOfMessages=10)

            if sqsResponse:

                if 'Messages' not in sqsResponse:
                    # Print a series of dotted lines while the job is processing
                    if dotLine<60:
                        print('.', end='')
                        dotLine=dotLine+1
                    else:
                        print()
                        dotLine=0
                    sys.stdout.flush() # Good practice: Clear buffer after python printing
                    continue

                for message in sqsResponse['Messages']: # Once SQS gets a msg that the job is done (or it failed)...
                    # Dig into the nested json message to extract and print info about the job status
                    notification = json.loads(message['Body'])
                    rekMessage = json.loads(notification['Message'])
                    print(rekMessage['JobId'])
                    print(rekMessage['Status'])
                    if str(rekMessage['JobId']) == response['JobId']:
                        print('Matching Job Found:' + rekMessage['JobId'])
                        jobFound = True
                        #=============================================
                        self.GetResultsPersonTracking(rekMessage['JobId']) # See method defined below
                        #=============================================

                        sqs.delete_message(QueueUrl=self.queueUrl,
                                       ReceiptHandle=message['ReceiptHandle'])
                    else:
                        print("Job didn't match:" +
                              str(rekMessage['JobId']) + ' : ' + str(response['JobId']))
                    # Delete the unknown message. Consider sending to dead letter queue
                    sqs.delete_message(QueueUrl=self.queueUrl,
                                   ReceiptHandle=message['ReceiptHandle'])

        print('done')


    def GetResultsPersonTracking(self, jobId):
        maxResults = 200
        paginationToken = '\n'
        finished = False

        while finished == False:
            response = self.rek.get_person_tracking(JobId=jobId,
                                            MaxResults=maxResults,
                                            NextToken=paginationToken,
                                            SortBy='TIMESTAMP')

            print('\n\nVideo compression codec: ', response['VideoMetadata']['Codec'])
            print('Video duration (seconds): ', str(response['VideoMetadata']['DurationMillis'] / 1000.))
            print('Video format: ', response['VideoMetadata']['Format'])
            print('Video framerate: ', response['VideoMetadata']['FrameRate'])

            for personDetection in response['Persons']:
                print('Detection Timestamp: ', str(personDetection['Timestamp']))
                print('Person index: ', personDetection['Person']['Index'])

                if 'Face' in personDetection['Person']:
                    print('FACE DETECTED')
                    print('Face yaw: ', personDetection['Person']['Face']['Pose']['Yaw'])
                    print('Face pitch: ', personDetection['Person']['Face']['Pose']['Pitch'])

            if 'NextToken' in response:
                paginationToken = response['NextToken']
            else:
                finished = True

if __name__ == "__main__":
    import time
    start_time = time.time()

    analyzer=VideoDetect()
    analyzer.main()

    print('\nRuntime in Seconds: ', (time.time() - start_time))
